{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"Terra saepe erat hic morte corrige pondera","text":""},{"location":"about/#laertaque-rudis","title":"Laertaque rudis","text":"<p>Lorem markdownum in alumnae albente; ducens habet levia spoliataque recepto optima; sertis et. Pertimuit ferenda acer optat celsa, manibusque caeso; mactati utraque dederat.</p> <ul> <li>Imitantes hominis ut</li> <li>Carmine simul</li> <li>Sic copia incultos fores spumigeroque Coeranon praemia</li> <li>Quae lavere</li> </ul>"},{"location":"about/#admoto-nube-patrias-facta-carpere-dicere-recepit","title":"Admoto nube patrias facta carpere dicere recepit","text":"<p>Ipsisque et virgo stetit dixit; et iuventa mater inhibere. Opus populi amor, quae, sed Telephon: est obscuram Amphitrite sacra corpus cornu. Tydides et carebis Dianae, neque neve carinis dentes adpellare per curru deus, ergo pro corpora ecce. Quoque vultu Hippolytum potentem numen, gemitus radice iacentem subiectaque. Sanctis unguibus Italico.</p> <p>Aquae est toto sed colloque mentes dixerat tamen, per illi, cum ventis relinquunt visi Phyleus. Magistris magna. In remisit translata digna sed fratres. Iuvenis coniugis non quas, nulli curvamine sacrata praeposito addere. Incipiens se tum rerum me furta ovantem triformis illa sub superiniecit funis ruitis.</p>"},{"location":"about/#parentis-caede","title":"Parentis caede","text":"<p>Ausis lustrantem mortis pollicitique aliud canes sustineat. Dat dignos, in levavit dubitat es fodit adspexit feritatis fudit; potest. Feros dirum levati lusuque nam ulterius, argentea, in quarto sonuere gignis refoventque feres purpureus. Hic mihi, cumulemus equorum teloque nescimus; quem domum ut vocatum crus, agant?</p>"},{"location":"about/#contineat-iura-inposuere-tendens","title":"Contineat iura inposuere tendens","text":"<p>Virili alta sociam constitit versatus vipereos de agitur, ira saeve quae nuntia. Commisi accessit cornigeris inter ecce denique nostra Thebae. Sorores dissimulat, de non fuit, artus, patris octavo.</p>"},{"location":"about/#deam-rursus-colunt-frequentat-canes-iunctissima-ab","title":"Deam rursus colunt frequentat canes iunctissima ab","text":"<p>Iris putando aderis: nata utimur otia nomine maiora cum: tum sublime tota cremarat, uni. Paruerit in fixumque caput isque iam sibi, et odissem moveri pervius, manu nisi quem. Ore vertice, pectus mihi ira, blandas scelus Trachasque; molire ulmi. Ubi spatio non matris, libera nomen attulerat verbere; terrae. Sum ipse prohibent poena.</p> <ul> <li>Indagine quae quibus infelix dixit fugientem avari</li> <li>Famulumque Cinyphius mutua Messapiaque Erysicthone aequora nuper</li> <li>Torum per Vulcania natura</li> </ul> <p>Et nescit sicco longoque cessent tempora. Di imperat nautae, grates impediunt valens demens est amantes nondum arborea procul orbem, soror.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Editor: Muhammed Burak Bu\u011frul</p> <p>Reviewers: Kadir Emre Oto &amp; Yusuf Hakan Kalayc\u0131</p>"},{"location":"introduction/#introduction_1","title":"Introduction","text":"<p>First of all, this is an intensive algorithm programme prepared by inzva, which includes lectures, contests, problem-solvings and a variety of practises. \"Competitive Programming\" term will be mentioned frequently in this programme, especially for it's community, help in progress in algorithms and data structures etc.</p> <p>Just for a quick cover up we will have a look at what happens when you compile and run a program, basic data types and functions. After that, we will examine C++ Standard Template Library(STL), time complexity and memory space.</p>"},{"location":"introduction/#command-line","title":"Command Line","text":"<p>A lot of people don't use command line if they can use an alternative. There are powerful IDEs (Integrated Development Environments) and they really make programming easier in some aspects. However, knowing how to use command line is important, especially for competitive programming. Firstly, it gives a low level knowledge and full control; secondly, every computer and environment has command line interface.</p> <p>In this document, you will find only a basic introduction to the command line, which is no more than the basic usage of a file system, compiler, and programs.</p> <p>There are a lot of differences between command line of Windows and Linux. But the differences between those of Mac and Linux are less.</p>"},{"location":"introduction/#linux-and-mac","title":"Linux and Mac","text":"<p>Mac users can use the built-in Terminal. You can find it by searching from Spotlight. Linux users can use gnome-terminal or any other installed one. Again, you can find them by using the built-in search tab.</p> <p>Some basic commands:</p> <ul> <li><code>ls</code> list files in current directory. Usage: <code>ls</code></li> <li><code>cd</code> change directory. Usage: <code>cd ~/Desktop</code></li> <li><code>mkdir</code> make a new directory. Usage: <code>mkdir directory_name</code></li> <li><code>mv</code> move command (cut). Usage: <code>mv source_path destination_path</code></li> <li><code>cp</code> copy command. Usage: <code>cp source_path destination_path</code></li> <li><code>rm</code> remove command. Usage: <code>rm file_path</code></li> </ul> <p>You can read more about the unix command line at: http://linuxcommand.org</p>"},{"location":"introduction/#compiling-and-executing-programs","title":"Compiling and Executing Programs","text":""},{"location":"introduction/#g","title":"G++","text":"<p>G++ is installed in Linux environments but in Mac, you should install Xcode first.</p> <p>You can compile your cpp souce file by typing <code>g++ source.cpp</code>. Default output of this command is <code>a.out</code>.</p>"},{"location":"introduction/#running-executable-files","title":"Running Executable Files","text":"<p>For Linux and Mac, the command to run a program is <code>./program_name</code>. If you use default <code>g++</code> command, the name of your program will be <code>a.out</code>, so you should type <code>./a.out</code> in order to run it.</p>"},{"location":"introduction/#closing-a-program","title":"Closing a Program","text":"<p>When you want to kill a program in running step, you can simply hit Control + C.</p> <p>When you want to suspend a program in running step, you can simply hit Control + Z.</p> <p>When you want to register EOF on standart input, you can simply hit Control + D.</p>"},{"location":"introduction/#inputoutput-redirection","title":"Input/Output Redirection","text":"<p>You can redirect input and output streams of a program by using command line and it is surprisingly easy.</p>"},{"location":"introduction/#saving-output-to-a-file","title":"Saving Output to a File","text":"<p>The only thing you need is <code>&gt;</code> symbol. Just add it at the end of your run command with the output file name: <code>./a.out &gt; output.txt</code></p> <p>Note: This redirection process creates <code>output.txt</code> if it doesn't exist; otherwise deletes all content in it, then writes into it. If you want to use <code>&gt;</code> in appending mode you should use <code>&gt;&gt;</code> instead.</p>"},{"location":"introduction/#reading-input-from-a-file","title":"Reading Input from a File","text":"<p>It is almost the same as output file redirection. The symbol is <code>&lt;</code> now. Usage: <code>./a.out &lt; input.txt</code></p> <p>This will make your job easier than copying and pasting input to test your program, especially in the contests.</p>"},{"location":"introduction/#using-both-at-the-same-time","title":"Using Both at the Same Time","text":"<p>One of the wonderful things about these redirections is that they can be used at the same time. You can simply add both to the end of your run command: <code>./a.out &lt; input.txt &gt; output.txt</code></p>"},{"location":"introduction/#pipe","title":"pipe","text":"<p>Sometimes, you may want to redirect the output of a program to another program as input. You can use the <code>|</code> symbol for this. Usage: <code>./program1 | ./program2</code></p>"},{"location":"introduction/#diff","title":"diff","text":"<p>As the name denotes, it can check two files line by line if they are the same or not. If not, it outputs different lines. Usage: <code>diff file1.txt file2.txt</code></p> <p>It is very useful for comparing output of brute force solution and real solution.</p>"},{"location":"introduction/#structs-and-classes","title":"Structs and Classes","text":"<p>In almost every programming language, you can define your own data type. C++ has structs, classes; Python has dictionaries, classes etc. You can think of them as packets that store more than one different data and implement functions at the simplest level. They have a lot more abilities than these two (You can check OOP out).</p> <p>Let us examine a fraction struct written in C++.</p> <p>We need to store two values for a fraction, numerator and denominator.</p> <pre><code>struct Fraction {\n  int numerator, denominator;\n};\n</code></pre> <p>This is the simplest definition of a struct. Fraction struct contains two <code>int</code> variables. We call them members. So, Fraction struct has two members called numerator and denominator.</p> <pre><code>#include &lt;cstdio&gt;\n\nstruct Fraction {\n    int numerator, denominator;\n};\n\nFraction bigFraction(Fraction a, Fraction b) {\n\n    if( a.numerator * b.denominator &gt; a.denominator * b.numerator )\n        return a;\n\n    return b;\n}\n\nint main() {\n    // Create two Fractions in order to compare them\n    Fraction a, b;\n\n    a.numerator = 15;\n    a.denominator = 20;\n\n    b.numerator = 12;\n    b.denominator = 18;\n\n    // Create a new Fraction in order to store biggest of Fraction a and Fraction b.\n    fraction biggest = bigFraction(a, b);\n\n    printf(\"The biggest fraction is %d / %d\\n\", biggest.numerator, biggest.denominator);\n    return 0;\n}\n</code></pre> <p>Let us do the same in Python3:</p> <pre><code>class Fraction:\n\n    def __init__(self, numerator, denominator):\n        self.numerator, self.denominator = numerator, denominator\n\ndef bigFraction(a, b):\n\n    if a.numerator * b.denominator &gt; a.denominator * b.numerator:\n        return a\n\n    return b\n\na, b = Fraction(15, 20), Fraction(12, 18)  # Create two Fractions in order to compare them\nbiggest = bigFraction(a, b)\n\nprint(biggest.numerator, biggest.denominator)\n</code></pre> <p>In the sample codes above, <code>a</code>, <code>b</code> and <code>biggest</code> are called objects of <code>Fraction</code>. Also, the word instance can be used instead of object.</p>"},{"location":"introduction/#the-arrow-operator-c","title":"The Arrow Operator (C++)","text":"<p>Sometimes, usage of struct can change in C++. When you have a pointer to a struct, you should use <code>-&gt;</code> to access its members instead of <code>.</code> operator. If you still want to use <code>.</code> operator, you should do in this way: <code>(*ptr).member</code>. But arrow operator is simpler: <code>ptr-&gt;member</code>.</p>"},{"location":"introduction/#big-o-notation","title":"Big O Notation","text":"<p>When dealing with algorithms or coming up with a solution, we need to calculate how fast our algorithm or solution is. We can calculate this in terms of number of operations. Big \\(\\mathcal{O}\\) notation moves in exactly at this point. Big \\(\\mathcal{O}\\) notation gives an upper limit to these number of operations. The formal definition of Big \\(\\mathcal{O}\\) is [1].</p> <p>Let \\(f\\) be a real or complex valued function and \\(g\\) a real valued function, both defined on some unbounded subset of the real positive numbers, such that \\(g(x)\\) is strictly positive for all large enough values of \\(x\\). One writes:</p> \\[f(x) = \\mathcal{O}{(g(x))} \\ as\\ x \\rightarrow \\infty\\] <p>If and only if for all sufficiently large values of x, the absolute value of \\(f(x)\\) is at most a positive constant multiple of \\(g(x)\\). That is, \\(f(x)\\) = \\(\\mathcal{O}{(g(x))}\\) if and only if there exists a positive real number \\(M\\) and a real number \\(x_0\\) such that:</p> \\[|f(x)| \\leq Mg(x)\\ for \\ all\\ x\\ such\\ that\\ x_0 \\leq x\\] <p>In many contexts, the assumption that we are interested in the growth rate as the variable \\(x\\) goes to infinity is left unstated, and one writes more simply that:</p> \\[f(x) = \\mathcal{O}(g(x))\\] <p>Almost every case for competitive programming, basic understanding of Big \\(\\mathcal{O}\\) notation is enough to decide whether to implement a solution or not.</p> <p>Note: Big \\(\\mathcal{O}\\) notation can be used for calculating both the run time complexity and the memory space used.</p>"},{"location":"introduction/#recursion","title":"Recursion","text":"<p>Recursion occurs when functions repeat themselves in order to create repeated applications or solve a problem by handling smaller situations first. There are thousands of examples in mathematics. One of the simple ones is factorial of \\(n\\). It can be shown by \\(n!\\) in mathematics and it gives the product of all positive integers from \\(1\\) to \\(n\\), for example, \\(4! = 1\\cdot 2\\cdot 3\\cdot 4 = 24\\). If we write factorial in a mathematical way, it will be:</p> \\[ \\begin{align*}     f(n) &amp;= \\begin{cases}     1 &amp; \\text{if $n = 0$\\,\\, } \\\\     n \\cdot f(n - 1) &amp; \\text{if $n &gt; 0$\\,\\,}     \\end{cases} \\end{align*} \\] <p>The reason why we didn't simply write it as \\(f(n) = n \\cdot f(n-1)\\) is that it doesn't give sufficient information about function. We should know where to end the function calls, otherwise it can call itself infinitely. Ending condition is \\(n = 0\\) here. We call it base case. Every recursive function needs at least one base case.</p> <p>So if we write every step of \\(f(4)\\), it will be:</p> \\[ \\begin{align*}     4!     &amp;= 4\\cdot f(3) &amp;&amp; \\text{recursive step} \\\\     &amp;= 4\\cdot 3\\cdot f(2) &amp;&amp; \\text{recursive step} \\\\     &amp;= 4\\cdot 3\\cdot 2\\cdot f(1) &amp;&amp; \\text{recursive step} \\\\     &amp;= 4\\cdot 3\\cdot 2\\cdot 1\\cdot f(0) &amp;&amp; \\text{recursive step} \\\\     &amp;= 4\\cdot 3\\cdot 2\\cdot 1\\cdot 1 &amp;&amp; \\text{base case} \\\\     &amp;= 24 &amp;&amp; \\text{arithmetic} \\end{align*} \\] <p>Basically, we can apply this recursive logic into programming:</p> <pre><code>int factorial(int n) {\n    int result = 1;\n    for(int i = 1; i &lt;= n; i++)\n        res *= i;\n    return result;\n}\n</code></pre> <p>We can say a function is a recursive if it calls itself. Let us change this iterative factorial function into a recursive one. When you imagine how the recursive code will look like, you will notice it will look like the mathematical one:</p> <pre><code>int factorial(int n) {\n    if(n == 0)\n        return 1;\n    return n * factorial(n - 1);\n}\n</code></pre> <p>Note that we didn't forget to put our base case into the recursive function implementation.</p>"},{"location":"introduction/#time-complexity","title":"Time Complexity","text":"<p>In case above, it can be seen that both recursive and iterative implementations of factorial function runs in \\(\\mathcal{O}{(n)}\\) time. But this equality doesn't occur always. Let us examine fibonacci function, it is mathematically defines as:</p> \\[ \\begin{align*}     f(n) &amp;= \\begin{cases}     1 &amp; \\text{if $n = 0$ or $n = 1$\\,\\, } \\\\     f(n - 1) + f(n - 2) &amp; \\text{if $n &gt; 1$\\,\\,}     \\end{cases} \\end{align*} \\] <p>We can implement this function with just one for loop:</p> <pre><code>int fibonacci(int n) {\n    int result = 1, previous = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        int tmp = result;\n        result += previous;\n        previous = tmp;\n    }\n    return result;\n}\n</code></pre> <p>Again, we can implement recursive one according to the mathematical formula:</p> <pre><code>int fibonacci(int n) {\n    if( n == 0 || n == 1 )\n        return 1;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n</code></pre> <p>Let us calculate time complexity of iterative one. There are three basic operations inside a for loop that repeats \\(n-2\\) times. So time complexity is \\(\\mathcal{O}(n)\\). But what about the recursive one? Let us examine its recursion tree(diagram of function calls) for \\(n = 5\\) on visualgo.</p> <p>\\(f\\) function called more than one for some values of n. Actually in every level, number of function calls doubles. So time complexity of the recursive implementation is \\(\\mathcal{O}{(2^n)}\\). It is far away worse than the iterative one. Recursive one can be optimized by techniques like memoization, but it is another topic to learn in further weeks.</p>"},{"location":"introduction/#mutual-recursion","title":"Mutual Recursion","text":"<p>Mutual recursion occurs when functions call each other. For example function <code>f</code> calls another function <code>g</code>, which also somehow calls <code>f</code> again.</p> <p>Note: When using mutual recursions in C++, don't forget to declare one of the functions so that the other function can know first one from its' prototype.</p> <p>Note 2: You can chain more than two functions and it will be still a mutual recursion.</p>"},{"location":"introduction/#enumeration-and-brute-force","title":"Enumeration and Brute-Force","text":"<p>Enumeration is numbering method on a set.</p> <p>For example, permutation is one of enumeration techniques. First permutation of numbers in range \\(1\\) and \\(n\\) is:</p> \\[1, 2, 3... n-1, n\\] <p>And second one is:</p> \\[1, 2, 3... n, n-1\\] <p>Finally, the last one is:</p> \\[n, n-1... 3, 2, 1\\] <p>Additionally, we can try to enumerate all possible distributions of \\(n\\) elements into 3 different sets. An example of a distribution of 5 elements can be represented as:</p> \\[1, 1, 2, 1, 3\\] <p>In this distribution the first, the second and the fourth elements goes into the first set; third element goes into second set and the last element goes into the third set.</p> <p>Enumerations can be done with recursive functions easily. We will provide example implementations of 3-set one. But before examining recursive implementation, let us try to implement iterative one:</p> <pre><code>#include &lt;cstdio&gt;\n\nint main(){\n\n    for( int i=1 ; i&lt;=3 ; i++ )\n        for( int j=1 ; j&lt;=3 ; j++ )\n            for( int k=1 ; k&lt;=3 ; k++ )\n                for( int l=1 ; l&lt;=3 ; l++ )\n                    for( int m=1 ; m&lt;=3 ; m++ )\n                        printf(\"%d %d %d %d %d\\n\", i, j, k, l, m);\n\n    return 0;\n}\n</code></pre> <p>It will print all possible distributions of 5 elements into 3 sets. But what if we had 6 elements? Yes, we should have added another for loop. What if we had \\(n\\) elements? We can not add infinite number of for loops. But we can apply same logic with recursive functions easily:</p> <pre><code>#include &lt;cstdio&gt;\n\nint ar[100];\n\nvoid enumerate( int element, int n ){\n\n    if( element &gt; n ){ // Base case\n\n        for( int i=1 ; i&lt;=n ; i++ )\n            printf(\"%d \", ar[i]);\n\n        printf(\"\\n\");\n        return;\n    }\n\n    for( int i=1 ; i&lt;=3 ; i++ ){\n        ar[element] = i;\n        enumerate(element + 1, n);\n    }\n}\n\nint main(){\n    enumerate(1, 5);\n    return 0;\n}\n</code></pre> <p>Brute-Force is trying all cases in order to achieve something(searching best, shortest, cheapest etc.).</p> <p>One of the simplest examples of brute-forces approaches is primality checking. We know that for a prime \\(P\\) there is no positive integer in range \\([2, P-1]\\) that evenly divides \\(P\\). We can simply check all integers in this range to decide if it is prime:</p> <pre><code>bool isPrime(int N) {\n    for( int i=2 ; i&lt;N ; i++ )\n        if( N % i == 0 )\n            return false;\n    return true;\n}\n</code></pre> <p>It is a simple function, but its' time complexity is \\(\\mathcal{O}(N)\\). Instead we can benefit from the fact if there is a positive integer \\(x\\) that evenly divides \\(N\\), there is a positive integer \\(\\frac{N}{x}\\) as well. As we know this fact, we can only check the integer in range \\([2, \\sqrt{N}]\\):</p> <pre><code>bool isPrime(int N) {\n    for( int i=2 ; i*i &lt;= N ; i++ )\n        if( N % i == 0 )\n            return false;\n    return true;\n}\n</code></pre> <p>Now, its' time complexity is \\(\\mathcal{O}{(\\sqrt{N})}\\). It is far away better than \\(\\mathcal{O}{(N)}\\).</p>"},{"location":"introduction/#built-in-data-structures-and-functions","title":"Built-In Data Structures and Functions","text":"<p>There is no need to reinvent the wheel. Every language has its' own built in data structures, functions etc. After this point, the document will be C++ centered. But Python alternatives will be given.</p>"},{"location":"introduction/#the-c-standard-template-library-stl","title":"The C++ Standard Template Library (STL)","text":"<p>The STL is a well known library for C++ that includes variety of data structures and algorithms.</p> <p>Note: Third party libraries generally not allowed in contests.</p>"},{"location":"introduction/#pairs","title":"Pairs","text":"<p>C++: Sometimes you may need to store two elements for an object. We can do this by creating a struct/class or two dimensional array. They will all work well but using pairs will be much more easier. You can think of pair as a class that has two variables named first and second. That's all for the basic. The good part is, you can decide their types(int, double, your own struct/class etc.). An example for pairs in C++:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n\n    pair&lt;int, int&gt; p(1, 2);\n    pair&lt;int, string&gt; p2;\n\n    p2.first = 3;\n    p2.second = \"Hey there!\";\n\n    pair&lt;pair&lt;int, string&gt;, string&gt; nested;\n\n    nested.first = p2;\n    nested.second = \"This is a nested one\";\n\n    cout &lt;&lt; \"Info of p -&gt; \" &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl;\n    cout &lt;&lt; \"Info of p2 -&gt; \" &lt;&lt; p2.first &lt;&lt; \" \" &lt;&lt; p2.second &lt;&lt; endl;\n    cout &lt;&lt; \"Info of nested -&gt; \" &lt;&lt; nested.first.first &lt;&lt; \" \" &lt;&lt; nested.first.second\n            &lt;&lt; \" \" &lt;&lt; nested.second &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Python: You can simply create a tuple or an array:</p> <pre><code>p = (1, 2)\np2 = [1, \"Hey there!\"]\nnested = ((3, \"inner?\"), \"outer\", \"this is a tuple you can add more\")\n\np2[0] = 3\n# nested[0] = \"don't\"  # In python you can't change tuples, but you can change arrays\n\nprint(p, p2, nested)\n</code></pre>"},{"location":"introduction/#vectors","title":"Vectors","text":"<p>C++: When using array, we should decide its size. What if we don't have to do this, what if we could add elements into it without considering the current size? Well, all these ideas take us to vectors.</p> <p>C++ has this structure. Its name is vector. It is a dynamic array but you don't have to think about its size. You can simply add elements into it. Like pairs, you can use it with any type (int, double, another vector, your struct/class etc.). Usage of a vector is very similar to classic array:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main(){\n\n    vector&lt;int&gt; ar;\n\n    for( int i=0 ; i&lt;10 ; i++ )\n        ar.push_back(i);\n\n    for( int i=0 ; i&lt;(int)ar.size() ; i++ )\n        cout &lt;&lt; ar[i] &lt;&lt; \" \";\n\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Python: Python lists already behave like vectors:</p> <pre><code>ar = []\n\nfor i in range(10):\n    ar.append(i)\n\nprint(ar)\n</code></pre>"},{"location":"introduction/#stacks-queues-and-deques","title":"Stacks, Queues, and Deques","text":"<p>C++: They are no different than stack, queue and deque we already know. It provides the implementation, you can simply include the libraries and use them. See queue, stack, deque.</p>"},{"location":"introduction/#priority-queues","title":"Priority Queues","text":"<p>It is basically a built-in heap structure. You can add an element in \\(\\mathcal{O}(logN)\\) time, get the first item in \\(O(logN)\\) time. The first item will be decided according to your choice of priority. This priority can be magnitude of value, enterence time etc.</p> <p>C++: The different thing for priority queue is you should add <code>#include &lt;queue&gt;</code>, not <code>&lt;priority_queue&gt;</code>. You can find samples here. Again, you can define a priority queue with any type you want.</p> <p>Note: Default <code>priority_queue</code> prioritizes elements by highest value first. Here is three ways of defining priority.</p> <p>Python: You can use heapq in python.</p>"},{"location":"introduction/#sets-and-maps","title":"Sets and Maps","text":"<p>C++: Now that we mentioned binary trees (heap above), we can continue on built-in self balanced binary trees. Sets are key collections, and maps are key-value collections. Sets are useful when you want to add/remove elements in \\(\\mathcal{O}(logN)\\) time and also check existence of an item(key) in \\(O(logN)\\) time. Maps basically do the same but you can change value associated to a key without changing the position of the key in the tree. You can check c++ references for set and map. You can define them with any type you want. If you want to use them with your own struct/class, you must implement a compare function.</p> <p>Python: You can use dictionaries for map and sets for set in python without importing any other libraries.</p>"},{"location":"introduction/#iterators","title":"Iterators","text":"<p>C++: You can use iterators for every built-in data structure in C++ for pointing their objects.</p> <p>Python: You can iterate through any iterable in python by using in. You can check this example.</p>"},{"location":"introduction/#sorting","title":"Sorting","text":"<p>C++: In almost every language, there is a built-in sort function. C++ has one as well. It runs in \\(\\mathcal{O}(N log N)\\) time. You can pass your own compare function into sort function of C++.</p> <p>Python: You can use sort function for any list or list like collection in order to sort them or if you don't want to change the original collection, you can use <code>sorted()</code> function instead. You can pass your own compare function into sort function of python by using key variable.</p>"},{"location":"introduction/#suggested-readings","title":"Suggested Readings","text":""},{"location":"introduction/#c","title":"C++","text":"<ul> <li>next_permutation: Link</li> <li>STL document: Link</li> <li>binary_search: Link</li> <li>upper_bound: Link</li> <li>lower_bound: Link</li> <li>reverse: Link</li> <li>fill: Link</li> <li>count: Link</li> </ul>"},{"location":"introduction/#python","title":"Python","text":"<ul> <li>bisect: Link</li> <li>collections: Link</li> <li>built-in functions: Link</li> <li>lambda: Link</li> </ul>"},{"location":"introduction/#references","title":"References","text":"<ol> <li>Landau, Edmund (1909). Handbuch der Lehre von der Verteilung der Primzahlen [Handbook on the theory of the distribution of the primes] (in German). Leipzig: B. G. Teubner. p. 31.</li> </ol>"}]}